INSTALL for GluCat 0.9.0 with PyClical
========================================

Prerequisites: Before You Begin
===============================

GluCat uses the C++ Standard Library and the Boost Library. The PyClical Python
extension module is built using Cython and Python. Make sure that you have all
of these installed and working before attempting to use GluCat with PyClical.
Use the instructions at http://www.boost.org/more/download.html to obtain
the Boost Library. Make sure that you are able to build the Boost library with
the same C++ compiler version as you will be using to build programs that will
use the GluCat library.

The default configuration of GluCat, as well as most combinations of
configuration options, require a compiler that supports the C++ 2011 standard.

Scroll to the end of these instructions to see a list of successful builds,
including version numbers of various software components, and notes on software
versions.


Installation from Git clone
===========================

You can install GluCat in one of two ways:
1. By cloning one of the Git repositories for GluCat;
2. By downloading a tarball.

To install the first way, from (e.g.) GitHub, run the following commands on a
Linux machine or equivalent Posix environment connected to the Internet:

> git clone git@github.com:penguian/glucat.git glucat-0.9.0
> cd glucat-0.9.0
> make -f admin/Makefile.common cvs

This results in a directory structure that includes glucat-0.9.0/configure,
allowing you to make and install GluCat in the same way as if you had downloaded
and unzipped the tarball glucat-0.9.0.tar.gz.


Directory Structure
===================

Once you have downloaded, unzipped and untarred the source code, or followed
the instructions above to install from Git clone, you should have a directory,
glucat-0.9.0. Under this directory you should see a number
of subdirectories, including ./admin, ./doc, ./glucat, ./gfft_test, ./products,
./pyclical, ./squaring, ./test, ./test_runtime, ./testxx, and ./transforms.

The following instructions are meant to be used with glucat-0.9.0 as the
current directory.


Installation Summary
====================

There are four different types of program that you can make using the GluCat
library with PyClical. These are:

 1. The PyClical Python extension module.
 2. The timing test programs.
 3. The regression test programs.
 4. Your own programs, written in C++.

There are four different things to install. These are:

 1. The PyClical Python extension module.
 2. The GluCat C++ header files.
 3. The basic documentation, including the PyClical demonstration scripts and
    notebooks.
 4. The GluCat API documentation.

The simplest way to install GluCat with PyClical is to run the following
commands, in order:

 ./configure
 make
 sudo make install
 make clean

This makes and installs the PyClical Python extension module and also
installs the GluCat header files, as well as the basic doumentation.

You can also make and install the GluCat API documentation, after running
"./configure", by running the following commands, in order:

 make doc
 sudo make install-doc
 make clean

More details of the installation process are given below.


The Four Different Types of Programs
=====================================

The PyClical Python extension module
------------------------------------

GluCat includes a Python extension module called PyClical.

The subdirectory ./pyclical contains source code for the PyClical extension
module, and the subdirectory ./pyclical/demos, contains demo and tutorial
scripts written in Python.

PyClical is written in C++ and Cython, and is defined in the files
pyclical/glucat.pxd, pyclical/PyClical.h, pyclical/PyClical.pxd, and
pyclical/PyClical.pyx.

The two types of test programs
------------------------------

GluCat includes two types of test programs, timing (benchmark) tests, and
functionality (regression) tests. The regression tests are also used as
programming examples. The source code for the timing tests is in ./gfft_test,
./products, ./squaring and ./transforms. The source code for the regression
tests is in the subdirectories ./test00 to ./test16. Compilation of these test
programs uses C++ headers defined in ./test as well as ./glucat.

Your own programs, written in C++
---------------------------------

Once you have installed  the GluCat C++ library, you use this library to build
your own C++ programs. To do this, you will need to follow some or all of the
same steps you took to build the test programs and the PyClical extension
module. This includes setting compiler flags, and including relevant headers
and libraries.

Pay special attention to the -D flags described in the configuration section
below, as these control optional parts of the compilation of the GluCat library.
In particular, if you compile your own programs without setting any of these
-D flags, please be aware that the default random number generator used by
GluCat requires the use of the C++ 2011 standard. See details below.

To automate the build process, you should use GNU make with your own Makefile.
For very elaborate software, you may also want to consider using GNU Autotools.


To Configure
============

The build process for PyClical and the test programs uses a single ./configure
shell script and a single overall Makefile, plus Makefiles in the relevant
subdirectories.

As briefly described above, the simplest way to install this package is:

 1. "cd" to the glucat-0.9.0 directory containing the source code and type
    "./configure" to configure GluCat with PyClical for your system.
    If you are using "csh" on an old version of System V, you might need to type
    "sh ./configure" instead to prevent "csh" from trying to execute
    ./configure itself.

    Running ./configure takes a while.  While running, it prints some messages
    telling which features it is checking for.

 2. Type "make" to compile PyClical and the timing tests.

 3. Type "make install" to install PyClical, the PyClical demos, the glucat
    header files, and any remaining data files and documentation. As with
    "make install-doc", you may need to use "sudo" or you may need to log
    in as "root" to perform this operation.

 4. You can remove the program binaries and object files from the source code
    directory by typing "make clean".

This section describes the first step in detail.

The ./configure shell script attempts to guess correct values for various
system-dependent variables used during compilation.  It uses those values to
create a Makefile in each relevant subdirectory.  It may also create one or
more ".h" files containing system-dependent definitions.  Finally, it creates a
shell script ./config.status that you can run in the future to recreate the
current configuration, a file  ./config.cache that saves the results of its
tests to speed up reconfiguring, and a file ./config.log containing compiler
output (useful mainly for debugging ./configure).

If you need to do unusual things to compile GluCat with PyClical, please try to
figure out how ./configure could check whether to do them, and email diffs or
instructions to the address given in the ./README file so they can be considered
for the next release.  If at some point ./config.cache contains results you don't
want to keep, you may remove or edit it.

The file ./configure.ac is used to create ./configure via a program called
"autoconf".  You only need ./configure.ac if you want to change or regenerate
 ./configure using a newer version of "autoconf".


Compilers and Options
---------------------

Some systems require unusual options for compilation or linking that the
./configure script does not know about.  You can give ./configure initial values
for variables by setting them in the environment.  Using a Bourne-compatible
shell, you can do that on the command line like this:
    CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure

Or on systems that have the "env" program, you can do it like this:
    env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure


Optional Features
-----------------

Defaults for the options are specified in brackets.

Installation directories:
  --prefix=PREFIX         install architecture-independent files in PREFIX
                          [/usr/local]

By default, "make install" will install the GluCat C++ headers in
/usr/local/include/glucat, and will install the PyClical.so shared object file
in a directory under /usr/local whose full pathname is determined by Python, for
example /usr/local/python3.7/site-packages. You can specify an installation
prefix other than /usr/local by using the option "--prefix=PREFIX", for example
"--prefix=$HOME".


  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
                          [PREFIX]

The option "--exec-prefix=EPREFIX" changes the installation prefix for PyClical,
without affecting the installation prefix for the GluCat C++ headers.


  --enable-debug[=ARG]    enables debug symbols (yes|no|full) [default=no]

This option controls debugging and optimization options. ARG can be "yes", "no"
or "full". The default is "no".

The option "--enable-debug=no" adds the compiler flag "-DNDEBUG" to CXXFLAGS in
the Makefiles, and turns on optimizations, such as adding the compiler flag
"-O3" to CXXFLAGS in the Makefiles, as well as a number of compiler and version
dependent optimization flags. The optimized compilation may take a long time to
complete.

The option "--enable-debug=yes" adds the compiler flag "-DNDEBUG" to CXXFLAGS in
the Makefiles, and turns on debugging, by adding the compiler flags "-O1 -g" to
CXXFLAGS in the Makefiles.

The option "--enable-debug=full" turns on full debugging, by adding the compiler
flags "-O0 -g3" to CXXFLAGS in the Makefiles, and does not add the compiler flag
"-DNDEBUG" to CXXFLAGS in the Makefiles.

The preprocessor symbol NDEBUG is used by Boost uBLAS to control debugging.
If NDEBUG is defined, then uBLAS compiles in release mode, including the use of
expression templates. If NDEBUG is not defined, then uBLAS compiles in debug
mode.


If you are compiling your own programs using the GluCat library, to control
debugging and performance, your Makefile needs to pass the following flags to
the C++ compiler.

 For full production and timing tests:
  "-DNDEBUG -O3"

 For testing with some debugging capability:
  "-DNDEBUG -O1 -g"

 For full debugging capability, including the use of debug code in uBLAS:
  "-O0 -g3"


  --disable-debug         disables debug output and debug symbols [default=yes]

Since the default for "--enable-debug" is "no", the option "--disable-debug"
does nothing.


  --enable-pyclical       uses Cython to build PyClical Python extension module
                          [default=yes]

This option determines whether the PyClical Python extension module is built.
The option "--enable-pyclical" sets the conditional flag make_pyclical in the
Makefile for GluCat, and adds the directory ./pyclical to the SUBDIRS list,
which is the list of subdirectories to be built. This is the default behaviour.
If you do not want to build PyClical, use the option "--disable-pyclical".

For PyClical to build successfully using pyclical/Makefile, you will need a
recent version of Python and (optionally) a recent version of Cython. You will
also need to ensure that the compiler can find the header file <Python.h>, by
using the "--with-extra-includes" option, if necessary. If your computer has
Python installed, but not Cython, you can build PyClical from the provided
PyClical.cpp file. See details in "To Build" below.

Building PyClical also builds pyclical/demos. This results in the creation of
Jupyter notebooks.


  --enable-check-isnan    check for NaN values at various places in the code [default=yes]

This option determines whether the GluCat library code uses the potentially
expensive isnan() member function to check for NaN values within the
matrix_multi<> implementations of operator*() and operator/().

The option --enable-check-isnan adds "-D_GLUCAT_CHECK_ISNAN" to CXXFLAGS in
the Makefiles. This is the default. If you do not want to check for NaN values,
you can use the option "--disable-check-isnan".

If D_GLUCAT_CHECK_ISNAN is defined, the functions operator*() and operator/()
in glucat/matrix_multi_imp.h use the member function isnan() to check for NaN
values in the LHS and RHS operands, and if either is NaN, then the result is NaN.
If D_GLUCAT_CHECK_ISNAN is not defined, then these chacks are not performed.

If you are compiling your own programs using the GluCat library, to check for
NaN values within operator*() and operator/(), your Makefile needs to pass
the flag "-D_GLUCAT_CHECK_ISNAN" to the C++ compiler.


Optional Packages
-----------------

  --with-extra-includes=DIR

This option adds non standard include paths.


  --with-extra-libs=DIR

This option adds non standard library paths.


  --with-demo-dir=DIR     [default=$DATAROOTDIR/pyclical/demos]

This option defines the installation directory for the PyClical demos.


  --with-stdlib[=ARG]     C++ standard library to use
                          (libcxx|libstdcxx)
                          [default=libstdcxx]

This option controls which C++ standard library is to be used. ARG can be
"libcxx" or "libstdcxx". The default is "libstdcxx".

The option "--with-stdlib=libcxx" is effective only when the clang++ compiler
is being used, as indicated by the environment variable $CXX. In this case,
the compiler flag "-stdlib=libc++" is added to CXXFLAGS. Note that if you use
libc++ with GluCat, you will need to ensure that any third party libraries
that you use are binary compatible with libc++. This may, in particular,
effect the building of PyClical.

If you are using clang++ to compile your own programs using the GluCat library,
to choose the libc++ library, add the compiler flag "-stdlib=libc++" to your
own compilation commands.

For further details, see http://libcxx.llvm.org/docs/


  --with-map[=ARG]        type of map to use
                          (map|stdunordered)
                          [default=stdunordered]

This option controls preprocessor symbols of the form _GLUCAT_USE_*_MAP that
determine the type of map used by glucat::framed_multi<>. ARG can be "map"
or "stdunordered". The default is "stdunordered".

The option "--with-map=map" adds nothing to CXXFLAGS in the Makefile, so that
glucat::framed_multi<> uses std::map<>.

The option "--with-map=stdunordered" adds "-D_GLUCAT_USE_STD_UNORDERED_MAP" to
CXXFLAGS in the Makefiles, if the header file <unordered_map> is usable.
If the g++ compiler is being used, the compiler flag "-std=c++11" rather than
"-ansi" is added to CXXFLAGS, to tell g++ to use the C++ 2011 standard.


By default glucat/framed_multi.h defines glucat::framed_multi<> using
std::map<>, which is a sorted map.

If _GLUCAT_USE_STD_UNORDERED_MAP is defined, glucat/framed_multi.h includes
the header file <unordered_map> and defines glucat::framed_multi<> using
std::unordered_map<>.


If you are compiling your own programs using the GluCat library, to choose the
type of map used by glucat::framed_multi<>, your Makefile needs to pass the
following flags to the C++ compiler, and the corresponding header files must
exist.

 For std::map<>: no flags.

 For std::unordered_map<>:
  "-D_GLUCAT_USE_STD_UNORDERED_MAP"
  If you are using g++, pass the compiler flag "-std=c++11" rather than "-ansi".
  This tells g++ to use the 2011 C++ standard.


  --with-pool-alloc       use Boost Pool allocator
                          [default=no]

This option determines whether the GluCat library code uses the Boost pool
allocator with objects of type std::map<>.

The option --with-pool-alloc adds "-D_GLUCAT_USE_BOOST_POOL_ALLOC" to CXXFLAGS
in the Makefiles.

If _GLUCAT_USE_BOOST_POOL_ALLOC is defined, glucat/framed_multi.h includes
the header file <boost/pool/poolfwd.hpp> and defines glucat::framed_multi<>
using boost::fast_pool_allocator<>; and glucat/framed_multi.h includes
the header file <boost/pool/pool_alloc.hpp>.

If you are compiling your own programs using the GluCat library, to use the
Boost pool allocator, your Makefile needs to pass the following flag to the
C++ compiler:  "-D_GLUCAT_USE_BOOST_POOL_ALLOC"

You will also need to ensure that the include path used by the compiler sees
<boost/pool/poolfwd.hpp> and <boost/pool/pool_alloc.hpp>. In addition, if you
are using Boost 1.50.0 or later, your Makefile needs to pass the following flag
to the C++ compiler, after all the linker-related flags: "-lboost_system"

You will also need to ensure that the library path sees libboost_system.*.
This requires that you have the Boost libraries built and installed.
See http://www.boost.org/more/getting_started/index.html and Boost tickets
https://svn.boost.org/trac/boost/ticket/7085
https://svn.boost.org/trac/boost/ticket/7335


  --with-dense-mat        uses dense matrices [default=yes]

This option controls the preprocessor symbol _GLUCAT_USE_DENSE_MATRICES that
determines the type of matrix used by glucat::matrix_multi<>.

The option "--with-dense-mat" adds "-D_GLUCAT_USE_DENSE_MATRICES" to CXXFLAGS in
the Makefiles. This is the default. If you do not want dense matrices, you can
use the option "--without-dense-mat".


If _GLUCAT_USE_DENSE_MATRICES is defined, glucat/matrix_multi.h defines
glucat::matrix_multi<> using ublas::matrix<>, which is a dense matrix.
Otherwise matrix_multi.h defines glucat::matrix_multi<> using
ublas::compressed_matrix<>, which a compressed matrix type. In either case,
basis matrices always use ublas::compressed_matrix<>.


To compile your own programs using the GluCat library with dense matrices,
your Makefile needs to pass the flag "-D_GLUCAT_USE_DENSE_MATRICES" to the C++
compiler.


  --with-qd               uses dd_real and qd_real [default=no]

This option controls the use of the QD high precision floating point library.

The option "--with-qd" adds "-D_GLUCAT_USE_QD" to CXXFLAGS and adds the flag
"-lqd" to the list of libraries, "all_libraries" in the Makefiles, if the header
file <qd/qd_real.h> and the library libqd are usable.


If _GLUCAT_USE_QD is defined, glucat/qd.h includes <qd/qd_real.h> and supports
the use of QD in GluCat by defining specializations for numeric_traits<dd_real>
and numeric_traits<qd_real>.


To compile your own programs using the GluCat library with QD, your Makefile
needs to pass the flags "-D_GLUCAT_USE_QD" and "-lqd" to the C++ compiler.
You will also need to ensure that the include path used by the compiler sees
<qd/qd_real.h> and the library path sees libqd.*.


  --with-random[=ARG]     type of random number generator to use
                          (std|gsl) [default=std]

This option controls preprocessor symbols of the form _GLUCAT_USE_*_MAP that
determine which random number generators are used by glucat::random_generator<>
defined in glucat/random.h. ARG can be "std" or "gsl". The default is
"std".

The option "--with-random=std" adds "D_GLUCAT_USE_STD_RANDOM" to CXXFLAGS in the
Makefiles, if the header file <random> is usable. If the g++ compiler is being
used, the compiler flag "-std=c++11" rather than "-ansi" is added to CXXFLAGS,
to tell g++ to use the C++ 2011 standard.

The option "--with-random=gsl" adds "-D_GLUCAT_USE_GSL_RANDOM" to CXXFLAGS and
adds the flags "-lgsl" and "-lgslcblas" to the list of libraries, "all_libraries"
in the Makefiles, if the header file <gsl/gsl_rng.h> and the libraries libgsl
and libgslcblas are usable.


By default the the C++ 2011 STD random number generators are used:
glucat/random.h includes <random>.

If _GLUCAT_USE_GSL_RANDOM is defined, the GSL random number generators are used:
glucat/random.h includes <gsl/gsl_rng.h> and <gsl/gsl_randist.h>.


If you are compiling your own programs using the GluCat library, to choose the
type of random number generators used by glucat::random_generator<>, your
Makefile needs to pass the following flags to the C++ compiler, and the
corresponding header files and libraries must be usable.

 For C++ 2011 STD random number generators:
  If you are using g++, pass the compiler flag "-std=c++11" rather than "-ansi".
  This tells g++ to use the 2011 C++ standard.

 For GSL random number generators:
  "-D_GLUCAT_USE_GSL_RANDOM -lgsl -lgslcblas"
  You will also need to ensure that the include path used by the compiler sees
  <gsl/gsl_rng.h> and the library path sees libgsl.* and libgslcblas.*.


  --with-eig[=ARG]        library to use for eigenvalues
                          (no|bindings) [default=no]

This option is used to control _GLUCAT_USE_EIGENVALUES and determine which
libraries to use. ARG can be "no" or "bindings". The default is "no".

The option "--with-eig=bindings" adds
"-D_GLUCAT_USE_EIGENVALUES -D_GLUCAT_USE_BINDINGS" to CXXFLAGS and adds the
flags "-llapack -lblas" to the list of libraries, "all_libraries" in the
Makefiles, if the header file <boost/numeric/bindings/driver/lapack/gees.hpp>
and the libraries liblapack and libblas are usable.


The preprocessor symbol _GLUCAT_USE_EIGENVALUES controls whether the sqrt() and
log() functions in glucat/matrix_multi_imp.h  detect and handle negative real
eigenvalues and imaginary eigenvalues correctly. If _GLUCAT_USE_EIGENVALUES is
defined, then sqrt() and log() call the function classify_eigenvalues(), defined
in glucat/matrix_imp.h, to detect negative real eigenvalues and imaginary
eigenvalues, and handle negative real eigenvalues by expanding the algebra.
Otherwise, sqrt() and log() operate as per GluCat 0.5.0 and earlier, which gives
incorrect results in the case of negative real eigenvalues.

The function eigenvalues() in glucat/matrix_imp.h calls an external function
to obtain the eigenvalues of a matrix. Which function is used depends on one of
a number of preprocessor symbols:

If _GLUCAT_USE_BINDINGS is defined, glucat/matrix_imp.h includes
<boost/numeric/bindings/lapack/driver/gees.hpp> and uses the SVN sandbox version
of the Boost Numeric Bindings library, as per
http://svn.boost.org/svn/boost/sandbox/numeric_bindings/.


To compile your own programs using the GluCat library, to detect and correctly
handle negative real eigenvalues in the sqrt() and log() functions, your
Makefile needs to pass the flag "-D_GLUCAT_USE_EIGENVALUES" to the C++ compiler,
as well as one of the following choices of flags, and the corresponding header
files and libraries must be usable.

 For Boost Numeric Bindings sandbox:
  "-D_GLUCAT_USE_BINDINGS -llapack -lblas"
  You will also need to ensure that the include path used by the compiler sees
  <boost/numeric/bindings/lapack/driver/gees.hpp> and the library path sees
 liblapack.* and libblas.*.


 --with-tuning[=ARG]     set of tuning parameters to use for testing
                         (slow|naive|fast|promoted|demoted)

The option "--with-tuning=arg" adds "-D_GLUCAT_TEST_TUNING_ARG" to CXXFLAGS,
where "ARG" is "arg" converted to uppercase. This option is unusual in that no
macro names of the form _GLUCAT_TEST_TUNING_ARG appear in the GluCat header
files. Such names appear only in the test header files. In particular the
header file test/tuning.h uses the macro names _GLUCAT_TEST_TUNING_SLOW,
_GLUCAT_TEST_TUNING_NAIVE, _GLUCAT_TEST_TUNING_FAST,
_GLUCAT_TEST_TUNING_PROMOTED and _GLUCAT_TEST_TUNING_DEMOTED to provide
different options for the tuning policy Tune_P.


Operation Controls
------------------

 ./configure recognizes the following options to control how it operates.

 --cache-file=FILE
      Use and save the results of the tests in FILE instead of
      ./config.cache.  Set FILE to "/dev/null" to disable caching, to debug the
      ./configure script.

 --help
      Print a summary of the options to ./configure, and exit.

 --quiet
 --silent
 -q
      Do not print messages saying which checks are being made.

 --srcdir=DIR
      Look for source code in directory DIR.  Usually ./configure can determine
      that directory automatically.

 --version
      Print the version of Autoconf used to generate the ./configure script,
      and exit.

 ./configure also accepts some other, not widely useful, options.


To Build
========

Building PyClical and the timing test programs
----------------------------------------------

To build PyClical and the timing test programs, set the environment variable
CXX to indicate your C++ compiler, eg. "g++" for GNU C++, "icpc" for Intel C++,
then run "./configure" as above, and then run "make".

Make uses the headers in ./glucat and ./test and the source in ./pyclical,
./gfft_test, ./products, ./squaring and ./transforms to build PyClical and the
timing test programs ./gfft_test/gfft_test, ./products/products,
./squaring/squaring and ./transforms/transforms.

The following build steps will be performed if you have not selected the
configuration option --disable-pyclical (equivalently, --enable-pyclical=no).

If Cython is installed then make builds PyClical by running the command

 ext_name="$(ext_name)" source_pyx="$(ext_name).pyx" \
 CXXFLAGS="$(EXTCXXFLAGS)" INCLUDES="$(INCLUDES)" LDFLAGS="$(LDFLAGS)" \
 python3 setup.py build_ext --inplace

with INCLUDES=$(all_includes), LDFLAGS=$(all_libraries) and the values of
CXXFLAGS,  all_includes, all_libraries and ext_name set by ./configure.
In particular, ext_name is set to "PyClical". You can run pyclical/setup.py
yourself, but you must set the environment variables ext_name, source_pyx,
CXXFLAGS, INCLUDES and LDFLAGS to appropriate values. See "To Configure" above
to determine these values.

Alternatively, if you have Python installed but do not have Cython, then
./configure will recognize this, and make will build PyClical via the command

 ext_name="$(ext_name)" source_cpp="$(ext_name)_nocython.cpp" \
 CXXFLAGS="$(EXTCXXFLAGS)" INCLUDES="$(INCLUDES)" LDFLAGS="$(LDFLAGS)" \
 python3 setup_nocython.py build_ext --inplace

with INCLUDES=$(all_includes), LDFLAGS=$(all_libraries) and the values of
CXXFLAGS,  all_includes, all_libraries and ext_name set by ./configure.
Again, you can run pyclical/setup_nocython.py yourself, but you must set all
of the relevant environment variables to appropriate values.

In the pyclical/demos directory, there is a Python script
build_pyclical_notebooks.py. This script builds a set of Jupyter notebooks
that correspond to the PyClical tutorials and some of the demos. Running make
will use this Python script to build these notebooks.


Building and running the regression test programs
-------------------------------------------------

To build and run the regression test programs, set the environment variable CXX
to indicate your C++ compiler, eg. "g++" for GNU C++, "icpc" for Intel C++,
then run "./configure" as above, and then run "make check". This builds and
runs the executable files ./test00/test00 to ./test16/test16. This produces
the intermediate output files ./test00/test00.out to ./test16/test16.out, and the
final test output file ./test_runtime/test.out. You can use a parallel make for
"make check" , e.g. "make check -j 6". This is especially useful on modern
multicore machines.

Warning:If you use too many jobs with parallel make, the compiler will have
problems obtaining enough memory to run efficiently.


To Test
=======

The test_runtime directory
--------------------------

The test runtime directory ./test_runtime contains sample test output files.

The sample test output files include eg3.res, gfft_test-11.out, products-8.out,
squaring-11.out and transforms-8.out. There are also 19 versions of the output
of the regression test. These are described below.

./test_runtime also contains the test input file eg8.txt. This file is needed
by programming example 8 (reading multivectors from input).


Re-running the regression tests
-------------------------------

The main regression test script is ./test/test.sh. Once you have built and run
the regression tests via "make check", you can use this script to re-run the
regression tests. The script ./test/test.sh reruns tests ./test00/test00 to
./test16/test16, using relative pathnames, so it is best to leave test.sh
where it is and invoke it using its full path name. This allows it to find
test00 to test16.

The test script ./test/test.sh takes any number (including zero) of numeric
parameters. Parameters in the range "00" to "16" correspond to coding examples
./test00/test00 to ./test16/test16. These examples are run in numerical
order. With zero parameters, all examples from 00 to 16 are run in order. Many
of the examples are run twice - once with framed_multi<Scalar_T> and once with
matrix_multi<Scalar_T>.

The ./test_runtime directory contains 19 sample versions of the regression test
results, corresponding to 19 different combinations of configuration parameters.
The tests were all run on an Intel(R) Core(TM) i7 CPU 870  @ 2.93GHz+ with

    Linux 5.11.0-25-generic #27-Ubuntu SMP x86_64
    Kubuntu 21.04
    gcc version 10.3.0 (Ubuntu 10.3.0-1ubuntu1)
    Boost 1.74 (1.74.0-8ubuntu2)
    Boost Numeric Bindings
    GSL 2.6 (2.6+dfsg-2)
    QD 2.3.22 (2.3.22+dfsg.1-3build1)
    Cython version 0.29.21
    Python 3.9.5

The test output file names and corresponding configuration commands are defined
in ./test/config-options.txt and are:

test.configure.default.out:
./configure

test.configure.compressed-mat:
./configure --without-dense-mat

test.configure.debug-full:
./configure --enable-debug=full

test.configure.debug-yes:
./configure --enable-debug=yes

test.configure.disable-check-isnan:
./configure --disable-check-isnan

test.configure.disable-dependency:
./configure --disable-dependency-tracking

test.configure.disable-pyclical:
./configure --disable-pyclical

test.configure.stdlib-libcxx:
./configure --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings \
--disable-pyclical --with-stdlib=libcxx

test.configure.eig-bindings:
./configure --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings

test.configure.eig-bindings-fast:
./configure --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings \
--with-tuning=fast

test.configure.eig-bindings-naive:
./configure --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings \
            --with-tuning=naive

test.configure.map-map-gsl:
./configure --with-map=map --with-random=gsl

test.configure.map-map-pool-alloc:
./configure --with-map=map --with-pool-alloc

test.configure.prefix-home-opt:
./configure --prefix=$HOME/opt

test.configure.qd-eig-bindings:
./configure --with-qd \
            --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings

test.configure.qd-eig-bindings-demoted:
./configure --with-qd \
            --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings \
            --with-tuning=demoted

test.configure.qd-eig-bindings-gsl:
./configure --with-qd \
            --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings \
            --with-random=gsl

test.configure.qd-eig-bindings-map-map:
./configure --with-qd \
            --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings \
            --with-map=map

test.configure.qd-eig-bindings-promoted:
./configure --with-qd \
            --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings \
            --with-tuning=promoted

When you run your own test using ./test/test.sh, you should compare its output
to the output file corresponding to the closest match to the configuration
options you used to build your copy of the GluCat library.

The reason why sample test results corresponding to 19 different combinations
of configuration parameters are included in test_runtime is that the test output
strongly depends on the configuration options chosen. In particular:

o If --with-qd is chosen, extra tests in ./test00/test00 and ./test11/test11 are
  done using the dd_real and qd_real scalar types.

o If --with-eig=X is chosen, with X set to bindings, the algorithms used for the
  square root, logarithm and inverse trig functions will become much more
  accurate, and more tests in ./test11/test11 will succeed.
  Even if one of these options are chosen, some tests in ./test11/test11 fail
  due to insufficient accuracy. This is most likely caused by a combination of
  excessive round off and truncation error with respect to the condition numbers
  of the matrices used in calculating these functions.

The tests typically use floating point arithmetic, and ./test00/test00 and
./test11/test11 in particular also use random number generators. Therefore if
you run the tests using different architecture, compilers or random number
generators, you should expect to have different floating point arithmetic
results, but generally, still within acceptable error tolerances, except as
noted for ./test11/test11 above.

The regression tests ./test00/test00 to ./test16/test16 recognize the program
arguments "--help", "--no-catch", and "--verbose". The "--no-catch" argument
disables the default exception catching behaviour of a regression test, to
allow prgram crashes to be more easily debugged. For ./test00/test00 and
./test11/test11 the argument "--verbose" produces verbose output essentially by
setting the error tolerance to zero. Verbose output can become quite large.

The test script ./test/test_optional.sh runs all examples 00 to 16 in order,
with the given parameters as program arguments.


Systematic regression testing
-----------------------------

The ./test directory contains the script ./test/test-all-config-options.sh.
This script uses the configuration given by the file ./test/config-options.txt
to build and run the regression tests and the PyClical doctests once for each
set of configuration options specified in the file. The syntax of each line of
the file  ./test/config-options.txt is simply

abbreviation: options

This corresponds to running the regression tests and doctests using the
configure command

./configure $options

and copying the output to ./test_runtime/test.configure.$abbreviation.out

For example:

The line

default:

specifies the abbreviation "default" and the options "", that is no options.

This corresponds to running the regression tests and doctests using the
configure command

./configure

and copying the output to ./test_runtime/test.configure.default.out

The line

map-map-gsl:                 --with-map=map --with-random=gsl

specifies the abbreviation "map-map-gsl" and the options
"--with-map=map --with-random=gsl". This corresponds to running the
regression tests and doctests using the configure command

./configure --with-map=map --with-random=gsl

and copying the output to ./test_runtime/test.configure.map-map-gsl.out

If you want to test with options different from those in the file
./test/config-options.txt, you can write your own file using the same syntax,
for example, som-other-file.txt, and invoke your tests with the command

config_options_file=some-other-file ./test/test-all-config-options.sh

You can also give parameters to ./test/test-all-config-options.sh and these
are passed to the make command. In particular, invoking (e.g.)

./test/test-all-config-options.sh -j 6

performs a parallel "make check" for each configuration option, potentially
speeding up the entire testing process.

Rather than running the regression tests in-place and copying the output
directly into ./test_runtime, the script ./test/test-all-config-options.sh
produces as many copies of the whole direcory glucat-0.9.0 as there are lines
in ./test/config-options.txt, naming them glucat-0.9.0.1 to glucat-0.9.0.19,
in the parent directory of glucat-0.9.0. This allows the effect of each set
of configuration options to be directly compared, and also ensures that any
side-effect of a configuration does not affect the test results of another
configuration.

The script ./test/diff-all-config-outputs.sh compares each relevant test output
file with the corresponding file in ./test_runtime or ./pyclical. For example,
line 11 of ./test/config-options.txt

map-map-gsl:                 --with-map=map --with-random=gsl

causes ./test/diff-all-config-outputs.sh to use diff to compare
glucat-0.9.0.11/test_runtime/test.configure.map-map-gsl.out to
glucat-0.9.0/test_runtime/test.configure.map-map-gsl.out, and compare
glucat-0.9.0.11/pyclical/test.out to glucat-0.9.0/pyclical/test.out.

Each comparison should only produce a line containing the line number of
the configuration being compared: 1 to 19.

The exceptional cases are:

1. If the configuration options have caused any sort of error.
2. Differences in compilers and libraries causing different floating point
   results. This currently occurs with the Intel C++ compiler, which produces
   output different from either the GNU C++ compiler or the Clang compiler.
   For example, QD version 2.3.16 contains an update that fixes a problem with
   tanh.

If the output of your systematic tests differs due to a difference in compilers
or libraries, you may want to copy this output to ./test_runtime to ease future
comparisons. To do so, run the script ./test/copy-all-config-outputs.sh.


Running the timing (benchmark) tests
------------------------------------

The test program ./gfft_test/gfft_test takes a parameter n, and transforms
larger and larger multivectors within the subalgebra defined by the frame of
the index set {-n, ..., -1, 1, ..., n}

The test program ./products/products takes a parameter n, and runs a timing
test which uses the products *, ^, % and & to multply larger and larger
multivectors within subalgebras defined by frames limited by the value of n.

The test program ./squaring/squaring takes a parameter n, and runs a timing
test which squares larger and larger multivectors within subalgebras defined
by frames limited by the value of n.

The test program ./transforms/transforms takes a parameter n, and transforms
larger and larger multivectors within the subalgebras defined by  frames
limited by the value of n.

The test script ./test/timing_tests.sh takes up to 4 numeric parameters.
The command "./test/timing_tests.sh $a $b $c $d" runs
 ./products/products $a
 ./squaring/squaring $b
 ./gfft_test/gfft_test $c
 ./transforms/transforms $d
The default is:
 ./products/products 8
 ./squaring/squaring 11
 ./gfft_test/gfft_test 11
 ./transforms/transforms 8

The sample timing test results in ./test_runtime are from programs
built and run using the configure command:
    ./configure --with-qd --with-eig=bindings  \
                --with-extra-includes=$PATHTO/numeric_bindings
on  Intel(R) Core(TM) i7 CPU 870  @ 2.93GHz+ with
    Linux 5.11.0-25-generic #27-Ubuntu SMP x86_64
    Kubuntu 21.04
    gcc version 10.3.0 (Ubuntu 10.3.0-1ubuntu1)
    Boost 1.74 (1.74.0-8ubuntu2)
    Boost Numeric Bindings
    QD 2.3.22 (2.3.22+dfsg.1-3build1)

Testing PyClical
----------------
Once you have built PyClical, run the doctests. In python3 or ipython3, etc.:

 >>> import PyClical
 >>> PyClical._test()
 TestResults(failed=0, attempted=629)
 >>> quit()

Alternatively, in the directory pyclical, run the script test.py using:

ipython3 --classic --no-banner < test.py

and compare the output with test.out.

In the directory pyclical/demos, the Python script files pyclical_demo.py and
sqrt_log_demo.py have corresponding output files pyclical_demo.out and
sqrt_log_demo.out. Run these two Python script files and compare their output to
the contents of the two output files. See the README under "Using the PyClical
extension module with Python" for instructions on how to run these files.


To Install
==========

Once you are satisfied that GluCat works, you can run "make install".
This install the headers from ./glucat into the header installation directory,
$PREFIX/include, which defaults to /usr/local/include. If you have chosen to
build PyClical, "make install" also installs the file PyClical.so into
a directory under $EPREFIX that is determined by the version of Python you are
running, for example /usr/local/python3.7/site-packages/.

Running "make install" will also install some documentation. Specifically, the
GNU top level doumentation files AUTHORS, ChangeLog, COPYING, glucat.lsm,
INSTALL, NEWS, README and TODO are installed into $DATAROOTDIR/doc/glucat. This
defaults to $PREFIX/share/doc/glucat, i.e. /usr/local/share/doc/glucat. The
PyClical demos and notebooks are installed by default into the directory
$DATAROOTDIR/pyclical/demos. This defaults to $PREFIX/share/pyclical/demos, i.e.
/usr/local/share/pyclical/demos. You can change this directory by using the
configuration option --with-demo-dir=DIR.

You will need permission to update the installation directories, so you may need
to use sudo, login as root, or su to root before you run make install.


 List of Successful Builds
 =========================

 GluCat 0.9.0 with PyClical has so far been built and tested using:

 1) Pensieri:
    4 core Intel(R) Core(TM) i7 CPU 870  @ 2.93GHz with

    Linux 5.13.0-22-generic #22-Ubuntu SMP x86_64
    Kubuntu 21.10

    The following compiler versions:
    1) gcc version 7.5.0 (Ubuntu 7.5.0-6ubuntu4)
    2) gcc version 11.2.0 (Ubuntu 11.2.0-7ubuntu2)
    3) clang version 9.0.1 (9.0.1-16.1ubuntu1)
    4) clang version 13.0.0 (13.0.0-2)
    5) icpx version 2021.4.0 (2021.4.0.20210924)
    6) icpx version 2022.0.0 (2022.0.0.20211123)

    Boost 1.74.0
    Boost Numeric Bindings
    GSL 2.6
    QD 2.3.22
    Cython 0.29.21
    Python 3.9.7
    Numpy 1.19.5
    Matplotlib 3.3.4
    Mayavi2 4.7.4
    VTK 9.1.0
    Doxygen 1.9.1
    pdfTeX 3.14159265-2.6-1.40.21 (TeX Live 2020/Debian)

    All 19 configuration commands corresponding to each of the 19
    test.configure*.out files in ./test_runtime

 2) Pensieri:
    4 core Intel(R) Core(TM) i7 CPU 870  @ 2.93GHz with

    Linux 5.13.0-22-generic #22-Ubuntu SMP x86_64
    Kubuntu 21.10

    The following compiler versions:
    1) gcc version 8.5.0 (Ubuntu 8.5.0-0ubuntu4)
    2) gcc version 9.4.0 (Ubuntu 9.4.0-3ubuntu1)
    3) gcc version 10.3.0 (Ubuntu 10.3.0-11ubuntu1)
    4) clang version 11.0.1 (11.0.1-2ubuntu5)
    5) clang version 12.0.1 (12.0.1-8build1)

    Boost 1.74.0
    Boost Numeric Bindings
    GSL 2.6
    QD 2.3.22
    Cython 0.29.21
    Python 3.9.7
    Numpy 1.19.5
    Matplotlib 3.3.4
    Mayavi2 4.7.1
    VTK 7.1.1
    Doxygen 1.9.1
    pdfTeX 3.14159265-2.6-1.40.21 (TeX Live 2020/Debian)

    ./configure --with-qd --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings

 3) Pensieri (VirtualBox):
    Virtual 1 core Intel(R) Core(TM) i7 CPU 870 @ 2.93GHz with

    Linux 5.15.5-1-default #1 SMP
    openSUSE Tumbleweed Release 20211202
    gcc (SUSE Linux) 11.2.1 20210816
    Boost 1.77.0
    Boost Numeric Bindings
    GSL 2.6-6.3
    QD 2.3.22-1.12
    Cython 0.29.24
    Python 3.8.12
    Numpy 1.21.2
    Matplotlib 3.4.3
    Mayavi2 4.7.4
    VTK 9.1.0
    Doxygen 1.9.2
    pdfTeX 3.141592653-2.6-1.40.22 (TeX Live 2021/TeX Live for SUSE Linux)

    ./configure --with-qd --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings

 4) Notturno:
    2 core AMD E-350 Processor 931.6 MHz with

    Linux 5.4.0-81-generic #91-Ubuntu SMP x86_64
    Kubuntu 20.04.3 LTS
    1) gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)
    2) clang version 10.0.0 (10.0.0-4ubuntu1)
    Boost 1.71.0
    Boost Numeric Bindings
    GSL 2.5
    QD 2.3.22
    Cython 0.29.14
    Python 3.8.10
    Numpy 1.17.4
    Matplotlib 3.1.2
    Mayavi2 4.7.1
    Doxygen 1.8.17
    pdfTeX 3.14159265-2.6-1.40.20 (TeX Live 2019/Debian)

    ./configure --with-qd --with-eig=bindings --with-extra-includes=$PATHTO/numeric_bindings
    
 5) NCI Gadi:
    48 core Intel(R) Xeon(R) Platinum 8274 CPU @ 3.20GHz with

    Linux  4.18.0-305.19.1.el8.nci.x86_64 SMP x86_64
    Rocky Linux release 8.4 (Green Obsidian)
    1) icpc version 2021.4.0
    2) icpx version 2021.4.0
    Boost 1.77.0
    Boost Numeric Bindings
    Cython 0.29.24
    Python 3.8.8
    Numpy 1.20.2
    
    ./configure --with-qd --with-eig=bindings \
                --with-extra-includes="${PATHTO}/numeric_bindings"
                   
 6) CoCalc:
    Virtual 8 core Intel(R) Xeon(R) CPU @ 2.80GHz with

    Linux 5.11.0-1020-gcp #22~20.04.1-Ubuntu SMP x86_64
    Ubuntu 18.04.5 LTS
    gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)
    Boost 1.65.1
    Boost Numeric Bindings
    Cython 0.29.21
    Python 3.6.9
    Numpy 1.18.5

    ../configure --with-qd --with-eig=bindings \
                 --with-extra-includes=/home/user/usr/local/include
                 --with-extra-libs=/home/user/usr/local/lib

 7) AWS Graviton:
    Virtual 4 core ARM Cortex-A72 Model 3 (AWS Graviton A1 image) with

    Linux 5.11.0-1016-aws #17~20.04.1-Ubuntu SMP aarch64
    Ubuntu 20.04 LTS
    gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)
    Boost 1.71.1
    Boost Numeric Bindings
    Cython 0.29.14
    Python 3.8.2

    ./configure --with-qd --with-eig=bindings \
                --with-extra-includes=/home/ubuntu/usr/local/include

                
Notes on software versions
--------------------------

    Building the documentation requires recent versions of both doxygen and
    latex, (e.g. texlive-2021).

    
    Using gcc version 11.X with Cython from any Conda environment that uses
    libstdc++ from gcc version 10.X and earlier (e.g. version 4.8.3) results
    in incompatible libstdc++ versions.
    see https://github.com/conda/conda/issues/10757
    and https://github.com/cython/cython/issues/4218
    and https://github.com/stan-dev/pystan/issues/294

    
    PyClical is now compatible with Python 3 and is backwards incompatible
    with Python 2.

    
    The PyClical plotting demos use Numpy and either Matplotlib or Mayavi2.
    The versions used need to be compatible with each other and with Python.
    For Mayavi2 the versions of VTK and TVTK used also need to be compatible.

    The use of Mayavi2 4.7.4 on Kubuntu 21.10 requires the following packages:

    Ubuntu packages
    ---------------
    python3-attr 20.3.0-1
    python3-configobj 5.0.6-4
    python3-idna 2.10-1
    python3-importlib-metadata 4.0.1-1
    python3-matplotlib 3.3.4-1
    python3-numpy 1:1.19.5-1ubuntu2
    python3-pygments 2.7.1
    python3-setuptools 52.0.0-4

    pip packages
    ------------
    aiohttp 3.8.1
    aiosignal 1.2.0
    apptools 5.1.0
    async-timeout 4.0.1
    charset-normalizer 2.0.9
    envisage 6.0.1
    frozenlist 1.2.0
    importlib-resources 5.4.0
    mayavi 4.7.4
    multidict 5.2.0
    pyface 7.3.0
    traits 6.3.2
    traitsui 7.2.1
    typ4.0.1
    vtk 9.1.0
    wsl1.2.1
    yarl 1.7.2
    zipp 3.6.0

    The use of Mayavi2 4.7.4 with Python 3.8 on openSUSE Tumbleweed
    requires the following RPM packages:

    mayavi 4.7.4-1.2
    python3-vtk 9.1.0-1.3
    python3-tvtk 4.7.4-1.2
    python38-apptools 4.5.0-1.10
    python38-configobj 5.0.6-3.12
    python38-envisage 6.0.1-1.2
    python38-importlib-metadata 4.8.1-1.1
    python38-importlib-resources 5.4.0-1.1
    python38-numpy 1.21.2-4.1
    python38-pyface 7.3.0-3.4
    python38-Pygments 2.9.0-2.1
    python38-setuptools 57.4.0-1.2
    python38-six 1.16.0-2.2
    python38-traits 6.3.1-1.1
    python38-traitsui 7.1.1-1.6
    python38-zipp 3.6.0-1.1


    Version incompatibilities discovered in testing pyclical/demos:

 1. Using Mayavi2 4.7.4 with VTK 9.1.0 on Kubuntu 21.10 results in the following
    warning message when running pyclical/demos/plotting_demo_dialog.py and
    pyclical/demos/plotting_demo_mayavi.py:

    WARNING: Imported VTK version (9.1) does not match the one used
             to build the TVTK classes (9.0). This may cause problems.
             Please rebuild TVTK.

    The plotting demos run normally.

 2. Using Mayavi2 4.7.1 with VTK 7.1.1 as per Kubuntu 21.04 yields two bugs
    likely caused by version mismatch:
    1. Running pyclical/demos/plotting_demo_mayavi.py results in:
    
       Warning: In ./Common/ExecutionModel/vtkAlgorithm.cxx, line 1419
       vtkGlyph3D (): Attempt to get connection index 0 for input port 0, 
       which has 0 connections. 
       
       A similar issue: 
       https://vtk.org/pipermail/vtk-developers/2014-May/014965.html
    2. The 3D plots produced by pyclical/demos/plotting_demo_mayavi.py have
       an incorrect z-order. A similar issue: 
       https://github.com/enthought/mayavi/issues/656

 3. Using Mayavi2 4.7.2 with VTK 9.0.1 and Python 3.8 on openSUSE
    Tumbleweed results in the following warning message when running
    pyclical/demos/plotting_demo_mayavi.py 
    
    /usr/lib64/python3.8/site-packages/vtkmodules/numpy_interface/algorithms.py:
    209: SyntaxWarning: "is" with a literal. Did you mean "=="?
      if max_dims is 1:


    The following bugs and workarounds apply to earlier versions of GluCat,
    and may still be applicable to GluCat 0.9.0, but have not been checked
    for this version.

 1. GluCat needs an include library which either defines the macro isnan or
    defines std::isnan. The C++ standard library included with gcc 4.5.2 and
    above defines std::isnan.

 2. Cython versions earlier than 0.15 do not build PyClical correctly,
    because PyClical uses generators, which were only implemented with
    Cython 0.15.

 3. Cython versions to and including 0.16 do not build PyClical correctly
    for C++11. If you try to use g++ with -std=c++11 you will see
    an error message like:

 In function ‘void __Pyx_RaiseArgtupleInvalid(...)’:
 error: unable to find string literal operator ‘operator"" PY_FORMAT_SIZE_T’

    See https://github.com/cython/cython/pull/109

    The workaround is to edit PyClical.cpp and put a space before and after each
    occurrence of PY_FORMAT_SIZE_T. This was fixed some time after Cython 0.16.

 4. GluCat will not work with QD versions earlier than 2.3.10, because older
    versions of QD do not zero-initialize dd_real and qd_real as required by
    ublas::clear().

 5. With clang++ 3.2, building PyClical results in the warning

clang: warning: argument unused during compilation: '--param ssp-buffer-size=4'

    This is harmless, and was fixed after Clang version 3.2.
    See http://llvm.org/bugs/show_bug.cgi?id=15327

 6. The following version incompatibility was observed during testing with
    GluCat 0.8.2:

    With g++ 5.3.1 and Boost 1.53.0 or Boost 1.55.0, the header file
    <boost/smart_ptr/shared_ptr.hpp> generates multiple warnings of the form:

warning: ‘template<class> class std::auto_ptr’ is deprecated [-Wdeprecated-declarations]

    This does not occur with g++ 4.8.5 and Boost 1.53.0, 1.55.0 or 1.61.0,
    nor with g++ 5.3.1 and Boost 1.58.0 or Boost 1.61.0.

See https://svn.boost.org/trac/boost/ticket/11411
    https://svn.boost.org/trac/boost/ticket/11622
